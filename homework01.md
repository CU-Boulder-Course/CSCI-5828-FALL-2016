<p align=center><b> #Homework 01 </b></p>
|First Name|Last Name|
|----------|--------|
|Shirong|Bai|

<hr>

<h3>Q1 - Essential Difficulties </h3>
Essential difficulties are those inherent of the intricate nature of 
software engineering. Brooks says, which I quote \[[1](#ref1)\]:
>There is no single development, in either technology or in management 
technique, that by itself promises even one order-of-magnitude improvement 
in productivity, in reliability, in simplicity.
>
>No inventions that will do for software productivity, reliability, and 
simplicity what electronics, transistors, and large-scale integration 
did for computer hardware.

Software project is intricate in nature. The essence of software entity 
is a construct of interlocking and abstract concepts: data sets, relationships 
among data types, algorithms and functions' invocation. To precisely 
represent real system with software in detail is conceptually difficult.

<h3>Q2 - Accidental Difficulties </h3>
According to Brooks \[[1](#ref1)\], Accidental difficulties are those
>attend its production but not inherent.

There is a characteristic of accidental difficulties that they can be 
attacked by multiple promising techniques: High-level languages, Time
sharing and Unified programming environments.
<h3>Q3 - Four Essential Difficulties </h3>

- **Complexity** :
The complexity of software is a essential property, not a accidental one. 
Like digital computers themselves are complex in size, software are
comprises of number of different elements, the communications among
elements are nonlinear so that make the software project unpredictable. 
Most of the classic problem of developing software derive from the the
essential difficulty and its nonlinear increase with size. Complexity could
be communication with team members, the difficulty of enumerating, and
the unreliability. Besides, management problem could be annoying too.
- **Conformity** :
Most of the complexity come from the arbitrary requirement in real life.
To make software function well, it has to be "forced without rhyme or reason"
 so that its interfaces conform. In real cases, conformation can come from
 most recent arrival of scenes and conformation to other interfaces.
- **Changeability** :
According to Brooks, \[[1](#ref1)\]

    > The software entity is constantly subject to pressures for change.

    Software embodies its function, and the function is under pressure of change.
A cultural matrix of applications, users, laws and machine vehicles require
software change continually.
- **Invisibility** :
Software is invisible and unvisualizable because the reality of software
is not inherently in space. To represent it, one has to abstract information
from real case. This abstraction in indeed more conceptual. A geometric
reality is captured in geometric abstraction.

<h3>Q4 - Why There Is No Silver Bullet for Software Engineering </h3>
From Brooks language, silver bullet is some technology that can improve
the performance by at least one order of magnitude. Due to the inherent
 complexity of software engineering, he thinks, considering current techniques,
 no significant improvement can be achieved so there is no silver bullet
 can slay that monster.
<h3>Q5 - Software Engineering vs. Computer Science </h3>
Chemical engineer is more engineering oriented, chemist cares more about
fundamental principle of chemistry. Software engineers share a similar
relationship with computer scientists just as chemical engineers shares with
chemists. For example, a well known problem is water spiting, water dissociate
into hydrogen molecule and oxygen molecule under the catalysis of light. Chemist
explore the mechanism behind it, how does it work. And chemical engineer
study how to make it work and how to improve its efficiency. One is science,
the other on is engineering. Detailed analogy is as following:
- **Goals** :
Like chemist study water splitting for the love of knowledge and are inspired
by interest, chemical engineer study it for practical purpose. Similarly,
 computer scientists purely study problems but software engineers solves 
 real problems.
- **Budgets** :
A chemical engineer has to make decision like purchasing based on budgets,
 chemists has less money issue to worry. This is the same for computer scientists
 software engineers, the later has to think more about budgets.
- **Demand and Potentials** :
A chemical engineer has to think the future use of research in real life.
Think about the demand and efficiency issue, chemist doesn't. Similarly,
software engineers must think about the demand of software, computer scientists
don't.
<h3>Q6 - Abstractions, Conversations, Specification, Translation, and Iteration </h3>


## References
1. <a name="ref1">Brooks</a>, F., <q>No Silver Bullet: Essence and 
Accidents of Software Engineering</q>. *Information Processing*, April, 1987.

<hr>