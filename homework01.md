<p align=center><b> #Homework 01 </b></p>
|First Name|Last Name|
|----------|--------|
|Shirong|Bai|

<hr>

<h3>Q1 - Essential Difficulties </h3>
Essential difficulties are those inherent of the intricate nature of 
software engineering. Brooks says, which I quote \[[1](#ref1)\]:
>There is no single development, in either technology or in management 
technique, that by itself promises even one order-of-magnitude improvement 
in productivity, in reliability, in simplicity.
>
>No inventions that will do for software productivity, reliability, and 
simplicity what electronics, transistors, and large-scale integration 
did for computer hardware.

Software project is intricate in nature. The essence of software entity 
is a construct of interlocking and abstract concepts: data sets, relationships 
among data types, algorithms and functions' invocation. To precisely 
represent real system with software in detail is conceptually difficult.

<h3>Q2 - Accidental Difficulties </h3>
According to Brooks \[[1](#ref1)\], Accidental difficulties are those
>"attend its production but not inherent".

There is a characteristic of accidental difficulties that they can be 
attacked by multiple promising techniques: High-level languages, Time
sharing and Unified programming environments.
<h3>Q3 - Four Essential Difficulties </h3>

- **Complexity** :
The complexity of software is a essential property, not a accidental one. 
Like digital computers themselves are complex in size, software are
comprises of number of different elements, the communications among
elements are nonlinear so that make the software project unpredictable. 
Most of the classic problem of developing software derive from the the
essential difficulty and its nonlinear increase with size. Complexity could
be communication with team members, the difficulty of enumerating, and
the unreliability. Besides, management problem could be annoying too.
- **Conformity** :
Most of the complexity come from the arbitrary requirement in real life.
To make software function well, it has to be "forced without rhyme or reason"
 so that its interfaces conform. In real cases, conformation can come from
 most recent arrival of scenes and conformation to other interfaces.
- **Changeability** :
According to Brooks, \[[1](#ref1)\]
>The software entity is constantly subject to pressures for change.

Software embodies its function, and the function is under pressure of change.
A cultural matrix of applications, users, laws and machine vehicles require
software change continually.
- **Invisibility** :
Software is invisible and unvisualizable because the reality of software
is not inherently in space. To represent it, one has to abstract information
from real case. This abstraction in indeed more conceptual. A geometric
reality is captured in geometric abstraction.

<h3>Q4 - Why There Is No Silver Bullet for Software Engineering </h3>

<h3>Q5 - Software Engineering vs. Computer Science </h3>

<h3>Q6 - Abstractions, Conversations, Specification, Translation, and Iteration </h3>


## References
1. <a name="ref1">Brooks</a>, F., <q>No Silver Bullet: Essence and 
Accidents of Software Engineering</q>. *Information Processing*, April, 1987.

<hr>